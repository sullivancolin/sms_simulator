{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"SMS Simulator","text":""},{"location":"#sms-simulator_1","title":"SMS Simulator","text":"<p>The objective is to simulate sending a large number of SMS alerts, like for an emergency alert service. The simulation consists of three parts:</p> <ol> <li>A producer that generates a configurable number of messages (default 1000) to random phone numbers. Each message contains up to 100 random characters.</li> <li>A configurable number of senders who pick up messages from the producer and simulate sending messages by waiting a random period of time distributed around a configurable mean. Senders also have a configurable failure rate.</li> <li>A progress monitor that displays the following and updates it every N seconds (configurable): Number of messages sent so far Number of messages failed so far Average time per message so far</li> </ol> <p>One instance each for the producer and the progress monitor will be started while a variable number of senders can be started with different mean processing time and error rate settings.</p>"},{"location":"#getting-started","title":"Getting Started","text":""},{"location":"#system-requirements","title":"System Requirements","text":"<p>Building the project and installing its dependencies requires an installation <code>Python 3.11</code> along with the <code>poetry</code> project workflow tool.</p>"},{"location":"#installation","title":"Installation","text":"<p>To create a virtual environment an install all the dependencies for the project run <pre><code>$ poetry install\n</code></pre> Alternatively, this repository contains a devcontainer configuration that will allow you to open the project inside a Docker environment with all the prequisites already set up.  If you have Docker installed, use VSCode and have the devcontainer extension installed, simply clicking on the above badge should launch the build process for you. Otherwise, if you clone the repository and open the workspace in VSCode you should be prompted to \"Reopen in Container\".  Pycharm may also support similar workflow</p>"},{"location":"#workspace-commands","title":"Workspace Commands","text":"<p>There is a Makefile with convenient targets for running tasks in the project like running tests, building and viewing the documentation, cleaning up artifacts etc. To view the list of available targets simple run: <pre><code>$ make\n</code></pre></p>"},{"location":"#starting-ray","title":"Starting Ray","text":"<p>The Queue and Sender workers are ochestrated using the ray multiprocessing and distributed computing framework. Before running any of the SMS simulator processes the ray runtime must be started in the background.  To start it run <pre><code>$ make start-ray\n</code></pre> or <pre><code>$ poetry run ray start --head\n</code></pre></p>"},{"location":"#stopping-ray","title":"Stopping Ray","text":"<p>To stop the ray runtime process run <pre><code>$ make stop-ray\n</code></pre> or <pre><code>$ poetry run ray stop\n</code></pre> If you wish to change the configuation paremeters of any running SMS sender processes or Queue, it is necessary to stop and restart the ray runtime before respawning the similator.</p>"},{"location":"#cli-interface-for-the-sms-service-simulator","title":"CLI interface for the sms service simulator","text":"<p>The main interface for interacting with the sms simulator is via a command line script named <code>sms</code>, which has 3 sub commands <code>generate</code>, <code>spawn-senders</code>, and <code>monitor</code></p> <p><pre><code> Usage: sms [OPTIONS] COMMAND [ARGS]...\n\n CLI interface for the sms service simulator.\n\n\u256d\u2500 Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 --version             -v        Print the current version.                                      \u2502\n\u2502 --install-completion            Install completion for the current shell.                       \u2502\n\u2502 --show-completion               Show completion for the current shell, to copy it or customize  \u2502\n\u2502                                 the installation.                                               \u2502\n\u2502 --help                          Show this message and exit.                                     \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\u256d\u2500 Commands \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 generate        Generate N SMS messages and add them to the queue.                              \u2502\n\u2502 monitor         Monitor SMS progress.                                                           \u2502\n\u2502 spawn-senders   Send SMS messages.                                                              \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> The command line script is only installed inside the virtual environment so you will need to prefix all invocations of <code>sms</code> with <code>poetry run</code> as in <pre><code>$ poetry run sms generate\n</code></pre> Alternatively, you may activate the virtual environment in a terminal session with <code>poetry shell</code> to avoid needing to use the prefix.</p> <p>To get instructions on how to use any of the subcommans just run <code>sms &lt;sub-command&gt; --help</code> for more detailed information.</p>"},{"location":"#example-usage","title":"Example Usage","text":"<p>The 3 processes may be started in any order, but will need separate terminal sessions for convenience.</p>"},{"location":"#1-start-the-monior-process","title":"1. Start the Monior Process","text":"<p>The following will display the monitor metrics updating every 1 second and looking for completed work in the <code>outbox</code> directory <pre><code>$ sms monitor --interval 1 outbox\n</code></pre></p>"},{"location":"#2-start-the-pool-of-sms-sender-workers","title":"2. Start the pool of SMS sender workers","text":"<p>THe following will start 8 worker processes in the background that will pull work off the queue in paralell process it with corresponding avg latency and error rate and place the completed work in the <code>outbox</code> directory. <pre><code>$ sms spawn-senders --num-workers 8 --latency-mean 50 --failure-rate .1 outbox\n</code></pre></p>"},{"location":"#3-generate-sms-messages","title":"3. Generate SMS Messages","text":"<p>The following will create 1000 sms messages with random phone numbers and messages between 1 and 100 characters long, write them as json files in the <code>inbox</code> directory, and add them to the queue for consumption by the senders <pre><code>$ sms generate --target-dir inbox 1000\n</code></pre></p>"},{"location":"#sample-output","title":"Sample output","text":""},{"location":"CLI/","title":"<code>sms</code>","text":"<p>CLI interface for the sms service simulator.</p> <p>Usage:</p> <pre><code>$ sms [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> <ul> <li><code>-v, --version</code>: Print the current version.</li> <li><code>--install-completion</code>: Install completion for the current shell.</li> <li><code>--show-completion</code>: Show completion for the current shell, to copy it or customize the installation.</li> <li><code>--help</code>: Show this message and exit.</li> </ul> <p>Commands:</p> <ul> <li><code>generate</code>: Generate N SMS messages and add them to...</li> <li><code>monitor</code>: Monitor SMS progress.</li> <li><code>spawn-senders</code>: Send SMS messages.</li> </ul>"},{"location":"CLI/#sms-generate","title":"<code>sms generate</code>","text":"<p>Generate N SMS messages and add them to the queue.</p> <p>Usage:</p> <pre><code>$ sms generate [OPTIONS] [N]\n</code></pre> <p>Arguments:</p> <ul> <li><code>[N]</code>: Number of sms messages to generate.  [default: 1000]</li> </ul> <p>Options:</p> <ul> <li><code>--target-dir TEXT</code>: Directory to write messages.  [default: inbox]</li> <li><code>--help</code>: Show this message and exit.</li> </ul>"},{"location":"CLI/#sms-monitor","title":"<code>sms monitor</code>","text":"<p>Monitor SMS progress.</p> <p>Usage:</p> <pre><code>$ sms monitor [OPTIONS] [TARGET_DIR]\n</code></pre> <p>Arguments:</p> <ul> <li><code>[TARGET_DIR]</code>: directory to watch for sms results  [default: outbox]</li> </ul> <p>Options:</p> <ul> <li><code>--interval FLOAT</code>: Refresh Metrics Interval in seconds.  [default: 1.0]</li> <li><code>--help</code>: Show this message and exit.</li> </ul>"},{"location":"CLI/#sms-spawn-senders","title":"<code>sms spawn-senders</code>","text":"<p>Send SMS messages.</p> <p>Usage:</p> <pre><code>$ sms spawn-senders [OPTIONS] [DEST_DIR]\n</code></pre> <p>Arguments:</p> <ul> <li><code>[DEST_DIR]</code>: directory to write success/failre messages  [default: outbox]</li> </ul> <p>Options:</p> <ul> <li><code>--num-workers INTEGER</code>: Number of workers to send messages.  [default: 3]</li> <li><code>--latency-mean INTEGER</code>: Mean latency in milliseconds.  [default: 50]</li> <li><code>--failure-rate FLOAT</code>: Rate of failure in sending messages.  [default: 0.1]</li> <li><code>--help</code>: Show this message and exit.</li> </ul>"},{"location":"Generate/","title":"Generate","text":"<p>Module to generate random SMS messages and enqueue them in the inbox.</p>"},{"location":"Generate/#sms_simulator.generate.random_phone_number","title":"random_phone_number","text":"<pre><code>random_phone_number() -&gt; int\n</code></pre> <p>Generate a random phone number.</p> <p>Returns:</p> Type Description <code>int</code> <p>A random phone number as an integer.</p> Source code in <code>sms_simulator/generate.py</code> <pre><code>def random_phone_number() -&gt; int:\n    \"\"\"Generate a random phone number.\n\n    Returns:\n        A random phone number as an integer.\n    \"\"\"\n    return int(\"1\" + \"\".join(str(num) for num in random.choices(numbers, k=9)))\n</code></pre>"},{"location":"Generate/#sms_simulator.generate.random_message","title":"random_message","text":"<pre><code>random_message() -&gt; str\n</code></pre> <p>Generate a random message string.</p> <p>Returns:</p> Type Description <code>str</code> <p>A random message string.</p> Source code in <code>sms_simulator/generate.py</code> <pre><code>def random_message() -&gt; str:\n    \"\"\"Generate a random message string.\n\n    Returns:\n        A random message string.\n    \"\"\"\n    return \"\".join(random.choices(string.ascii_letters, k=random.randint(1, 100)))\n</code></pre>"},{"location":"Generate/#sms_simulator.generate.get_n_messages","title":"get_n_messages","text":"<pre><code>get_n_messages(n: int = 1000) -&gt; Iterable[SMS]\n</code></pre> <p>Generate n random SMS messages.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>The number of messages to generate.</p> <code>1000</code> <p>Returns:</p> Type Description <code>Iterable[SMS]</code> <p>An iterable of SMS messages.</p> Source code in <code>sms_simulator/generate.py</code> <pre><code>def get_n_messages(n: int = 1000) -&gt; Iterable[SMS]:\n    \"\"\"Generate n random SMS messages.\n\n    Args:\n        n: The number of messages to generate.\n\n    Returns:\n        An iterable of SMS messages.\n\n    \"\"\"\n    return (\n        SMS(\n            random_phone_number(),\n            random_message(),\n        )\n        for _ in range(n)\n    )\n</code></pre>"},{"location":"Generate/#sms_simulator.generate.enqueue_messages","title":"enqueue_messages","text":"<pre><code>enqueue_messages(messages: Iterable[SMS], path: Path) -&gt; None\n</code></pre> <p>Enqueue messages in the inbox, and write them to destination path.</p> <p>Parameters:</p> Name Type Description Default <code>messages</code> <code>Iterable[SMS]</code> <p>An iterable of SMS messages.</p> required <code>path</code> <code>Path</code> <p>The destination path to write the messages to.</p> required Source code in <code>sms_simulator/generate.py</code> <pre><code>def enqueue_messages(messages: Iterable[SMS], path: Path) -&gt; None:\n    \"\"\"Enqueue messages in the inbox, and write them to destination path.\n\n    Args:\n        messages: An iterable of SMS messages.\n        path: The destination path to write the messages to.\n    \"\"\"\n    inbox = Queue(\n        maxsize=1000,\n        actor_options={\n            \"name\": \"inbox\",\n            \"namespace\": \"sms\",\n            \"lifetime\": \"detached\",\n            \"get_if_exists\": True,\n        },\n    )\n    for message in messages:\n        filename = path / (uuid4().hex + \".json\")\n        with open(filename, \"w\") as f:\n            json.dump(asdict(message), f)\n        inbox.put(filename)\n</code></pre>"},{"location":"Models/","title":"Models","text":"<p>Module defining the data models used in the SMS simulator.</p>"},{"location":"Models/#sms_simulator.models.SMSStatus","title":"SMSStatus","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p> <p>Enum of possible SMS statuses.</p> <p><code>SMSStatus.SUCCESS</code>: The SMS was successfully sent. <code>SMSStatusFAILED</code>: The SMS failed to send.</p> Source code in <code>sms_simulator/models.py</code> <pre><code>class SMSStatus(str, Enum):\n    \"\"\"Enum of possible SMS statuses.\n\n    `SMSStatus.SUCCESS`: The SMS was successfully sent.\n    `SMSStatusFAILED`: The SMS failed to send.\n    \"\"\"\n\n    SUCCESS = \"success\"\n    FAILED = \"failed\"\n</code></pre>"},{"location":"Models/#sms_simulator.models.SMS","title":"SMS  <code>dataclass</code>","text":"<p>Data class representing an SMS message.</p> Source code in <code>sms_simulator/models.py</code> <pre><code>@dataclass(frozen=True, slots=True)\nclass SMS:\n    \"\"\"Data class representing an SMS message.\"\"\"\n\n    phone_number: int\n    message: str\n</code></pre>"},{"location":"Models/#sms_simulator.models.SMSResult","title":"SMSResult  <code>dataclass</code>","text":"<p>Data class representing the result of sending an SMS message.</p> Source code in <code>sms_simulator/models.py</code> <pre><code>@dataclass(frozen=True, slots=True)\nclass SMSResult:\n    \"\"\"Data class representing the result of sending an SMS message.\"\"\"\n\n    phone_number: int\n    message: str\n    status: SMSStatus\n    latency: int\n</code></pre>"},{"location":"Monitor/","title":"Monitor","text":"<p>Monitor the metrics of the SMS Senders and message queue.</p>"},{"location":"Monitor/#sms_simulator.monitor.AddedFile","title":"AddedFile","text":"<p>             Bases: <code>DefaultFilter</code></p> <p>Watch Filter for files that have been added.</p> Source code in <code>sms_simulator/monitor.py</code> <pre><code>class AddedFile(DefaultFilter):\n    \"\"\"Watch Filter for files that have been added.\"\"\"\n\n    def __call__(self, change: Change, path: str) -&gt; bool:\n        \"\"\"Check if the change is an added file.\n\n        Args:\n            change: The type of change.\n            path: The path of the file.\n\n        Returns:\n            True if the change is an added file, False otherwise.\n        \"\"\"\n        return super().__call__(change, path) and change == Change.added\n</code></pre>"},{"location":"Monitor/#sms_simulator.monitor.AddedFile.__call__","title":"__call__","text":"<pre><code>__call__(change: Change, path: str) -&gt; bool\n</code></pre> <p>Check if the change is an added file.</p> <p>Parameters:</p> Name Type Description Default <code>change</code> <code>Change</code> <p>The type of change.</p> required <code>path</code> <code>str</code> <p>The path of the file.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the change is an added file, False otherwise.</p> Source code in <code>sms_simulator/monitor.py</code> <pre><code>def __call__(self, change: Change, path: str) -&gt; bool:\n    \"\"\"Check if the change is an added file.\n\n    Args:\n        change: The type of change.\n        path: The path of the file.\n\n    Returns:\n        True if the change is an added file, False otherwise.\n    \"\"\"\n    return super().__call__(change, path) and change == Change.added\n</code></pre>"},{"location":"Monitor/#sms_simulator.monitor.RowData","title":"RowData  <code>dataclass</code>","text":"<p>Data class representing the metrics of the SMS Senders and message queue.</p> Source code in <code>sms_simulator/monitor.py</code> <pre><code>@dataclass()\nclass RowData:\n    \"\"\"Data class representing the metrics of the SMS Senders and message queue.\"\"\"\n\n    refresh_count: int = 0\n    queue_size: int = 0\n    sent_count: int = 0\n    failed_count: int = 0\n    failure_rate: float = 0.0\n    throughput_avg: float = 0.0\n    latencies: float = 0.0\n\n    def to_table_row(self) -&gt; tuple[str, str, str, str, str, str, str]:\n        \"\"\"Convert the data to a table row tuple.\"\"\"\n        return (\n            f\"{self.refresh_count}\",\n            f\"{self.queue_size}\",\n            f\"{self.sent_count}\",\n            f\"[red]{self.failed_count}\",\n            f\"[red]{self.failed_count / self.sent_count if self.sent_count else 0.0:.2f} errs/sent\",\n            f\"{self.throughput_avg:.2f} messages/second\",\n            f\"{self.latencies/self.sent_count if self.sent_count else 0.0} ms/msg\",\n        )\n</code></pre>"},{"location":"Monitor/#sms_simulator.monitor.RowData.to_table_row","title":"to_table_row","text":"<pre><code>to_table_row() -&gt; tuple[str, str, str, str, str, str, str]\n</code></pre> <p>Convert the data to a table row tuple.</p> Source code in <code>sms_simulator/monitor.py</code> <pre><code>def to_table_row(self) -&gt; tuple[str, str, str, str, str, str, str]:\n    \"\"\"Convert the data to a table row tuple.\"\"\"\n    return (\n        f\"{self.refresh_count}\",\n        f\"{self.queue_size}\",\n        f\"{self.sent_count}\",\n        f\"[red]{self.failed_count}\",\n        f\"[red]{self.failed_count / self.sent_count if self.sent_count else 0.0:.2f} errs/sent\",\n        f\"{self.throughput_avg:.2f} messages/second\",\n        f\"{self.latencies/self.sent_count if self.sent_count else 0.0} ms/msg\",\n    )\n</code></pre>"},{"location":"Monitor/#sms_simulator.monitor.generate_table","title":"generate_table","text":"<pre><code>generate_table(row_data: RowData = RowData()) -&gt; Table\n</code></pre> <p>Generate a table from the row data.</p> <p>Parameters:</p> Name Type Description Default <code>row_data</code> <code>RowData</code> <p>The row data to generate the table from.</p> <code>RowData()</code> <p>Returns:</p> Type Description <code>Table</code> <p>A rich Table object.</p> Source code in <code>sms_simulator/monitor.py</code> <pre><code>def generate_table(row_data: RowData = RowData()) -&gt; Table:\n    \"\"\"Generate a table from the row data.\n\n    Args:\n        row_data: The row data to generate the table from.\n\n    Returns:\n        A rich Table object.\n    \"\"\"\n    table = Table()\n    table.add_column(\"Number of Refreshes\")\n    table.add_column(\"Queue Size\")\n    table.add_column(\"Sent Messages\")\n    table.add_column(\"Failed Messages\")\n    table.add_column(\"Failure Rate\")\n    table.add_column(\"Throughput (msgs/sec)\")\n    table.add_column(\"Average latency (ms)\")\n    table.add_row(*row_data.to_table_row())\n    return table\n</code></pre>"},{"location":"Monitor/#sms_simulator.monitor.monitor_results","title":"monitor_results","text":"<pre><code>monitor_results(source_dir: Path, interval: float) -&gt; None\n</code></pre> <p>Monitor the metrics of the SMS Sender processes and message queue.</p> <p>Parameters:</p> Name Type Description Default <code>source_dir</code> <code>Path</code> <p>The directory to watch for SMS results.</p> required <code>interval</code> <code>float</code> <p>The refresh interval in seconds.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>sms_simulator/monitor.py</code> <pre><code>def monitor_results(source_dir: Path, interval: float) -&gt; None:\n    \"\"\"Monitor the metrics of the SMS Sender processes and message queue.\n\n    Args:\n        source_dir: The directory to watch for SMS results.\n        interval: The refresh interval in seconds.\n\n    Returns:\n        None\n    \"\"\"\n    prev_time = None\n    queue = Queue(\n        maxsize=1000,\n        actor_options={\n            \"name\": \"inbox\",\n            \"namespace\": \"sms\",\n            \"lifetime\": \"detached\",\n            \"get_if_exists\": True,\n        },\n    )\n    row_data = RowData(0, queue.qsize(), 0, 0, 0.0, 0.0, 0.0)\n    with Live(generate_table(row_data), refresh_per_second=interval) as live:\n        for changes in watch(\n            str(source_dir), watch_filter=AddedFile(), step=int(interval * 1000)\n        ):\n            start_time = prev_time if prev_time else datetime.now()\n            batch_count = 0\n            for _, filename in changes:\n                if not Path(filename).exists():\n                    continue\n                with open(filename) as f:\n                    sms = SMSResult(**json.load(f))\n\n                row_data.sent_count += 1\n                batch_count += 1\n                row_data.latencies += sms.latency\n                if sms.status == SMSStatus.FAILED:\n                    row_data.failed_count += 1\n                Path(filename).unlink()\n            prev_time = datetime.now()\n            row_data.throughput_avg = (\n                batch_count / (prev_time - start_time).total_seconds()\n            )\n            row_data.refresh_count += 1\n            row_data.queue_size = queue.qsize()\n            live.update(generate_table(row_data))\n</code></pre>"},{"location":"Send/","title":"Send","text":"<p>Spawn Processes to Send SMS Messages</p>"},{"location":"Send/#sms_simulator.send.SMSSender","title":"SMSSender","text":"<p>Actor class to send SMS messages from the queue in it's own process.</p> Source code in <code>sms_simulator/send.py</code> <pre><code>@ray.remote\nclass SMSSender:\n    \"\"\"Actor class to send SMS messages from the queue in it's own process.\"\"\"\n\n    def __init__(\n        self, inbox: Queue, target_dir: Path, latency_mean: int, failure_rate: float\n    ):\n        \"\"\"Initialize the SMSSender actor.\n\n        Args:\n            inbox: A queue of source file paths containing SMS messages.\n            target_dir: The directory to write the result files to.\n            latency_mean: The mean latency in milliseconds for sending the SMS message.\n            failure_rate: The rate of failure for sending the SMS message.\n        \"\"\"\n        self.inbox = inbox\n        self.target_dir = target_dir\n        self.latency_mean = latency_mean\n        self.failure_rate = failure_rate\n\n    def send_messages(self) -&gt; None:\n        \"\"\"Send SMS messages from the inbox queue.\"\"\"\n        while True:\n            try:\n                source_path = self.inbox.get(timeout=1)\n            except Empty:\n                continue\n            send_message(\n                source_path, self.target_dir, self.latency_mean, self.failure_rate\n            )\n</code></pre>"},{"location":"Send/#sms_simulator.send.SMSSender.__init__","title":"__init__","text":"<pre><code>__init__(inbox: Queue, target_dir: Path, latency_mean: int, failure_rate: float)\n</code></pre> <p>Initialize the SMSSender actor.</p> <p>Parameters:</p> Name Type Description Default <code>inbox</code> <code>Queue</code> <p>A queue of source file paths containing SMS messages.</p> required <code>target_dir</code> <code>Path</code> <p>The directory to write the result files to.</p> required <code>latency_mean</code> <code>int</code> <p>The mean latency in milliseconds for sending the SMS message.</p> required <code>failure_rate</code> <code>float</code> <p>The rate of failure for sending the SMS message.</p> required Source code in <code>sms_simulator/send.py</code> <pre><code>def __init__(\n    self, inbox: Queue, target_dir: Path, latency_mean: int, failure_rate: float\n):\n    \"\"\"Initialize the SMSSender actor.\n\n    Args:\n        inbox: A queue of source file paths containing SMS messages.\n        target_dir: The directory to write the result files to.\n        latency_mean: The mean latency in milliseconds for sending the SMS message.\n        failure_rate: The rate of failure for sending the SMS message.\n    \"\"\"\n    self.inbox = inbox\n    self.target_dir = target_dir\n    self.latency_mean = latency_mean\n    self.failure_rate = failure_rate\n</code></pre>"},{"location":"Send/#sms_simulator.send.SMSSender.send_messages","title":"send_messages","text":"<pre><code>send_messages() -&gt; None\n</code></pre> <p>Send SMS messages from the inbox queue.</p> Source code in <code>sms_simulator/send.py</code> <pre><code>def send_messages(self) -&gt; None:\n    \"\"\"Send SMS messages from the inbox queue.\"\"\"\n    while True:\n        try:\n            source_path = self.inbox.get(timeout=1)\n        except Empty:\n            continue\n        send_message(\n            source_path, self.target_dir, self.latency_mean, self.failure_rate\n        )\n</code></pre>"},{"location":"Send/#sms_simulator.send.send_message","title":"send_message","text":"<pre><code>send_message(source_path: str, target_dir: Path, latency: int, failure_rate: float) -&gt; None\n</code></pre> <p>Send an SMS message.</p> <p>Parameters:</p> Name Type Description Default <code>source_path</code> <code>str</code> <p>The path to the source file containing the SMS message.</p> required <code>target_dir</code> <code>Path</code> <p>The directory to write the result file to.</p> required <code>latency</code> <code>int</code> <p>The mean latency in milliseconds for sending the SMS message.</p> required <code>failure_rate</code> <code>float</code> <p>The rate of failure for sending the SMS message.</p> required Source code in <code>sms_simulator/send.py</code> <pre><code>def send_message(\n    source_path: str, target_dir: Path, latency: int, failure_rate: float\n) -&gt; None:\n    \"\"\"Send an SMS message.\n\n    Args:\n        source_path: The path to the source file containing the SMS message.\n        target_dir: The directory to write the result file to.\n        latency: The mean latency in milliseconds for sending the SMS message.\n        failure_rate: The rate of failure for sending the SMS message.\n    \"\"\"\n    with open(source_path) as f:\n        sms = SMS(**json.load(f))\n    if random.random() &lt; failure_rate:\n        status = SMSStatus.FAILED\n    else:\n        status = SMSStatus.SUCCESS\n    latency = int(max(0, random.gauss(latency)))\n    time.sleep(latency / 1000)\n    result = SMSResult(sms.phone_number, sms.message, status, latency)\n    with open(target_dir / Path(source_path).name, \"w\") as f:\n        json.dump(asdict(result), f)\n    Path(source_path).unlink()\n</code></pre>"},{"location":"Send/#sms_simulator.send.spawn_sms_senders","title":"spawn_sms_senders","text":"<pre><code>spawn_sms_senders(destination: Path, num_workers: int, latency_mean: int, failure_rate: float, inbox: Queue | None = None) -&gt; None\n</code></pre> <p>Spawn background SMS worker actors to pull SMS messages from the inbox queue and send them to the output destination.</p> <p>Parameters:</p> Name Type Description Default <code>destination</code> <code>Path</code> <p>The directory to write the result files to.</p> required <code>num_workers</code> <code>int</code> <p>The number of worker actors to spawn.</p> required <code>latency_mean</code> <code>int</code> <p>The mean latency in milliseconds for sending the SMS message.</p> required <code>failure_rate</code> <code>float</code> <p>The rate of failure for sending the SMS message.</p> required Source code in <code>sms_simulator/send.py</code> <pre><code>def spawn_sms_senders(\n    destination: Path,\n    num_workers: int,\n    latency_mean: int,\n    failure_rate: float,\n    inbox: Queue | None = None,\n) -&gt; None:\n    \"\"\"Spawn background SMS worker actors to pull SMS messages from the inbox queue and send them to the output destination.\n\n    Args:\n        destination: The directory to write the result files to.\n        num_workers: The number of worker actors to spawn.\n        latency_mean: The mean latency in milliseconds for sending the SMS message.\n        failure_rate: The rate of failure for sending the SMS message.\n    \"\"\"\n    if not inbox:\n        inbox = Queue(\n            maxsize=1000,\n            actor_options={\n                \"name\": \"inbox\",\n                \"namespace\": \"sms\",\n                \"lifetime\": \"detached\",\n                \"get_if_exists\": True,\n            },\n        )\n    actors = [\n        SMSSender.options(  # type: ignore\n            name=f\"Actor ID: {num}\",\n            namespace=\"sms\",\n            lifetime=\"detached\",\n            get_if_exists=True,\n        ).remote(inbox, destination, latency_mean, failure_rate)\n        for num in range(num_workers)\n    ]\n    for actor in actors:\n        actor.send_messages.remote()\n</code></pre>"}]}